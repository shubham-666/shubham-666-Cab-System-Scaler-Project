const express = require("express");
const Logger = require("./../connect/logg");
const USER = require("./../models/user");
const ALLBOOKING = require("./../models/allBooking");
const userBooking = express.Router();
const nodemailer = require("nodemailer");
const db_elements = require("./../connect/getENV");

// Using nodemailer transporter object
const transporter = nodemailer.createTransport({
    service: "gmail", // Service you want to use
    auth: {
        user: db_elements.db_email, // Your email for sending mails
        pass: db_elements.dp_email_pass, // App password generated by Google
    },
});

const dateObject = new Date(); // Creating a date and time object for the timestamp

// Update user booking route - Adds the user to the USER schema who have booked the cab
// Records maximum detail of the drive and sends a confirmation email to the user about the booking
userBooking.post("/update-user-booking", async (req, res) => {
    const email = req.body.email;
    const cab_obj = req.body.obj;

    const hours = dateObject.getHours();
    const minutes = dateObject.getMinutes();
    const seconds = dateObject.getSeconds();
    const date = `0${dateObject.getDate()}`.slice(-2);
    const month = `0${dateObject.getMonth() + 1}`.slice(-2);
    const year = dateObject.getFullYear();
    const timestamp = `${year}-${month}-${date} ${hours}:${minutes}:${seconds}`;

    cab_obj["booking_time"] = timestamp;
    cab_obj["user_journey_time"] = req.body.total_time;
    cab_obj["user_total_price"] = req.body.total_price;
    cab_obj["user_source"] = req.body.source;
    cab_obj["user_destinations"] = req.body.dest;

    try {
        const existingUser = await USER.findOne({ user_email: email }).exec();

        if (existingUser === null) {
            // If the user is a new customer
            const newUser = await USER.insertMany([{ user_email: email }]);
            const updateQuery = { user_email: email };
            const updateData = {
                $push: {
                    user_cabs: cab_obj,
                },
            };

            // Update the user's details in the schema
            const updatedUser = await USER.findOneAndUpdate(updateQuery, updateData);

            // Update the schema of all bookings
            const allBookingData = await ALLBOOKING.insertMany([
                {
                    cab_name: cab_obj["cab_name"],
                    cab_price: cab_obj["user_total_price"],
                    cab_image: cab_obj["cab_image"],
                    cab_type: cab_obj["cab_type"],
                    cab_seats: cab_obj["cab_seats"],
                    user_email: email,
                },
            ]);

            // Setting up mail options and template
            const mailOptions = {
                from: db_elements.db_email,
                to: email,
                subject: "Booking Confirmed!!",
                text: `Booking Confirmed ${cab_obj["cab_name"]},\n Total price of Trip = Rs${cab_obj["user_total_price"]}/-only,\n User Email: ${email},\n date&time : ${cab_obj["booking_time"]}`,
            };

            // Send the confirmation email
            transporter.sendMail(mailOptions, function (error, info) {
                if (error) {
                    Logger.Logg.error(error);
                } else {
                    Logger.Logg.success("Email Sent: " + info.response);
                }
            });

            Logger.Logg.success("User CREATED, data added SUCCESSFULLY");
            res.status(200).send({ message: "InsertUpdateSuccess", data: email });
        } else {
            // If the user is an existing customer
            const latestUserCab = existingUser.user_cabs[existingUser.user_cabs.length - 1];
            const userCabBookingTime = latestUserCab.booking_time.split(" ");
            const currentTime = timestamp.split(" ");
            const t1 = userCabBookingTime[userCabBookingTime.length - 1];
            const t2 = currentTime[currentTime.length - 1];
            const tt1 = t1.split(":");
            const tt2 = t2.split(":");
            const time1 = parseInt(tt1[1]);
            const time2 = parseInt(tt2[1]);
            const hour1 = parseInt(tt1[0]);
            const hour2 = parseInt(tt2[0]);
            const ansTime = time2 - time1;

            // Check if the user is already in a cab
            if (hour2 === hour1) {
                if (ansTime < req.body.total_time) {
                    res.status(200).send({ message: "Already In a Cab!!", data: false });
                    return;
                }
            }

            const updateQuery = { user_email: email };
            const updateData = {
                $push: {
                    user_cabs: cab_obj,
                },
            };

            // Update the user's cab section with the latest booking
            const updatedUser = await USER.findOneAndUpdate(updateQuery, updateData);

            // Update the allbooking schema for the latest booking
            const allBookingData = await ALLBOOKING.insertMany([
                {
                    cab_name: cab_obj["cab_name"],
                    cab_price: cab_obj["user_total_price"],
                    cab_image: cab_obj["cab_image"],
                    cab_type: cab_obj["cab_type"],
                    cab_seats: cab_obj["cab_seats"],
                    user_email: email,
                },
            ]);

            // Setting up mail options and template
            const mailOptions = {
                from: db_elements.db_email,
                to: email,
                subject: "Cab Booking Confirmed!!",
                text: `Booking Confirmed ${cab_obj["cab_name"]},\n Total price of Trip = Rs${cab_obj["user_total_price"]}/-only,\n User Email: ${email},\n date&time : ${cab_obj["booking_time"]}`,
            };

            // Send the confirmation email
            transporter.sendMail(mailOptions, function (error, info) {
                if (error) {
                    Logger.Logg.error(error);
                } else {
                    Logger.Logg.success("Email Sent: " + info.response);
                }
            });

            Logger.Logg.success("Data UPDATED SUCCESSFULLY");
            res.status(200).send({ message: "UpdateSuccess", data: email });
        }
    } catch (error) {
        Logger.Logg.error(error.message);
        res.status(404).json({ message: error.message });
    }
});

// Fetching all the user's data for the admin display
// This API provides full details about the users
userBooking.get("/user/get-data", async (req, res) => {
    try {
        // Fetching all the users from the USER schema
        const userData = await USER.find().exec();

        if (userData !== null) {
            res.status(200).send({ message: "fetchSuccess", data: userData });
            Logger.Logg.success("All user data fetched successfully");
        } else {
            Logger.Logg.error("All user data fetch failed");
            res.status(200).send({ message: "fetchFailed", data: {} });
        }
    } catch (error) {
        Logger.Logg.error(error.message);
        res.status(404).json({ message: error.message });
    }
});

module.exports = userBooking;
